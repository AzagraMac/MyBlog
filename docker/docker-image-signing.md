# Docker image signing

<figure><img src="../.gitbook/assets/image (11).png" alt=""><figcaption></figcaption></figure>

Most Docker images are distributed without any verification that they're what they claim to be. You can increase trust in your images by digitally signing them. This proves to users that you published the image, not an imposter.

Docker's signing system is known as [content trust](https://docs.docker.com/engine/security/trust). It's exposed through the docker trust CLI command. Content Trust uses key sets to let registries verify the identity of prospective publishers. Users of signed images can be confident they come from the expected source.

### Generating Keys

You'll need a key pair to start using Content Trust. Key pairs can be issued by certificate authorities or generated by the Docker CLI.

```sh
docker trust key generate your-organization-or-your-name
```

to create a key. You'll be prompted to enter a passphrase. This will need to be supplied each time you use the key to sign or verify images. Press enter at each prompt to continue.

Example

```sh
# docker trust key generate jose-azagra
Generating key for jose-azagra...
Enter passphrase for new jose-azagra key with ID 25f7336: 
Repeat passphrase for new jose-azagra key with ID 25f7336: 
Successfully generated and loaded private key. Corresponding public key available: /root/jose-azagra.pub
```

Once you are done, set the private key to

```sh
/home/$USER/.docker/trust/private
```

and the public key in

```sh
/home/$USER/your-name.pub
```

The private key should never be shared and must not be lost.

\
If you need to move between machines, you can import a private key file into another Docker installation using

```sh
docker trust key load your-name.pub
```

### Adding your Public Key to your Registry

Docker Hub supports all the features of docker trust. If you're using a [private Docker Registry server](https://www.howtogeek.com/devops/how-to-create-your-own-private-docker-registry/), a slightly different configuration process is required.

The Registry server doesn't offer built-in signature support. You need a separate [Docker Notary](https://hub.docker.com/\_/notary) service that handles signature verification for image pushes and pulls. Notary [has three components](https://github.com/theupdateframework/notary/blob/master/docs/running\_a\_service.md), the server, a signing service, and a MySQL database. It [should be deployed](https://docs.docker.com/engine/security/trust/trust\_delegation) on the same URL as your registry server.

You can get Notary up and running by using its Docker Compose file:

```sh
git clone https://github.com/theupdateframework/notary.git
docker compose up -d
```

This basic deployment will run with a self-signed TLS certificate. It's intended for development use only. You'll need to trust the certificate authority file fixtures/root-ca.crt in the repository before clients can successfully connect.

```sh
sudo mkdir -p /usr/share/ca-certificates/extra
sudo cp fixtures/root-ca.crt /usr/share/ca-certificates/extra/notary.crt
sudo update-ca-certificates
```

\
The commands above will copy the certificate file into the ca-certificates storage location. update-ca-certificates reloads all certificates, adding the Notary authority to your system.

If you're going to run Notary in production, you'll need to setup authentication so only authorized users can add new keys. The NOTARY\_AUTH environment variable should be set when starting the service with docker-compose. This accepts Base64-encoded credentials in username:password format. You'll be prompted to supply these when interacting with Notary.

```sh
export NOTARY_AUTH=$(echo "username" | base64):$(echo "password" | base64)
docker compose up -d
```

Now you're ready to add your public key to your Notary server. Keys are added on a per-repository basis. This lets you isolate images from each other and enables support for [delegated third-party contributors](https://docs.docker.com/engine/security/trust/trust\_delegation). You can add other individuals with publish rights later on by getting them to repeat the command with their private key.

```sh
docker trust signer add your-key-name your-organization/my-image:tag
```

You'll need to enter the key's passphrase. It'll then be available on your registry server.

### &#x20;Signing Images

Once your key's on the registry, you can start to sign images. Use the docker trust sign command. Make sure each image is tagged with the correct registry URL.

```sh
docker trust sign your-organization/my-image:tag
```

\
This command will sign the image with your key and then push it straight up to the registry. There's no need to manually run docker push afterwards. You'll need to setup a repository key and passphrase to protect the individual image's trust data. Follow each prompt to setup your signing keys.\
\
Example

```sh
# docker trust sign azagramac/wireguard:latest
You are about to create a new root signing key passphrase. This passphrase
will be used to protect the most sensitive key in your signing system. Please
choose a long, complex passphrase and be careful to keep the password and the
key file itself secure and backed up. It is highly recommended that you use a
password manager to generate the passphrase and keep it safe. There will be no
way to recover this key. You can find the key in your config directory.
Enter passphrase for new root key with ID 452f86b: 
Repeat passphrase for new root key with ID 452f86b: 
Enter passphrase for new repository key with ID 3d58f13: 
Repeat passphrase for new repository key with ID 3d58f13: 
Enter passphrase for azagramac key with ID 25f7336: 
Created signer: azagramac
Finished initializing signed repository for azagramac/wireguard:latest
Signing and pushing trust data for local image azagramac/wireguard:latest, may overwrite remote trust data
The push refers to repository [docker.io/azagramac/wireguard]
385d04b1dc9b: Layer already exists 
5a7dcc022b75: Layer already exists 
678fa68f1478: Layer already exists 
17911c4b87a4: Layer already exists 
5fa6c2fe4047: Layer already exists 
953f06f22e41: Layer already exists 
30d1112a34d2: Layer already exists 
latest: digest: sha256:d627d93cbdb7483028dba364b5de9cbc8194b0188c59fcb278dc00b3bae30104 size: 1782
Signing and pushing trust metadata
Enter passphrase for azagramac key with ID 25f7336: 
Successfully signed docker.io/azagramac/wireguard:latest
```

When signing an image, it will ask several times for credentials.

If you've got existing workflows using docker push, you can opt for that command instead of docker trust. Complete the preceding steps to create a key and add it to Notary. Set the DOCKER\_CONTENT\_TRUST environment variable to have Docker CLI commands detect Content Trust and apply it automatically.

```sh
export DOCKER_CONTENT_TRUST=1
docker push your-organization/my-image:tag
```

\
You'll see the shell output matches what docker trust sign produces. Docker performs the same actions as the more explicit command.

### Verifying Trusted Images

The DOCKER\_CONTENT\_TRUST variable reappears with greater importance when it comes to verifying images you pull. Docker does not attempt to verify images by default, even if they contain trust data. You must set the environment variable in your shell to activate content trust validation.

```sh
export DOCKER_CONTENT_TRUST=1
docker pull your-organization/my-image:tag
```

When the variable is set, all image pulls will be checked against their registry's Notary server. If Notary can't provide any trust data, the image is treated as unsigned and the pull will be aborted. This protects you from images published by malicious actors masquerading as a genuine publisher.

\
Docker Enterprise users can configure an optional daemon setting to prevent Docker Engine from working with untrusted images already on the host. These may have arrived in tar archives from an unsafe source.

Edit /etc/docker/daemon.json and add the following key:

```json
{
    "content-trust": {
        "mode": "enforced"
    }
}
```

\
Reload the Docker daemon configuration with systemctl reload docker to apply the change.

You can inspect the trust status of an image using docker trust inspect. This will show the signatures associated with the image, allowing you to check whether it's been signed.

```sh
docker trust inspect your-organization/my-image:tag
```

\
Example

```sh
docker trust inspect azagramac/wireguard:latest
[
    {
        "Name": "azagramac/wireguard:latest",
        "SignedTags": [
            {
                "SignedTag": "latest",
                "Digest": "d627d93cbdb7483028dba364b5de9cbc8194b0188c59fcb278dc00b3bae30104",
                "Signers": [
                    "azagramac"
                ]
            }
        ],
        "Signers": [
            {
                "Name": "azagramac",
                "Keys": [
                    {
                        "ID": "25f7336640375e1ce3a3c02927ebefcf6fa6f7220b70fae0270901c5a00d38e2"
                    }
                ]
            }
        ],
        "AdministrativeKeys": [
            {
                "Name": "Root",
                "Keys": [
                    {
                        "ID": "3fe5826fbb57333b4dc9414c003d14381873af5747c42819b184e5f18b33f13b"
                    }
                ]
            },
            {
                "Name": "Repository",
                "Keys": [
                    {
                        "ID": "3d59f13d8d0a84ad2f415df0ea120bf116b40b0faf48b682b2db305f925191d3"
                    }
                ]
            }
        ]
    }
]
```

If you've published an image which you no longer want to sign, use the docker trust revoke command. This will delete the image's trust data, causing it to fail all subsequent Docker client verifications.

```sh
docker trust revoke your-organization/my-image:tag
```

### Summary

Docker Content Trust adds digital signatures to the Docker ecosystem, increasing safety when using images. If you push images to Docker Hub, you've already got everything you need to use the feature. Set the DOCKER\_CONTENT\_TRUST environment variable and use Docker commands as normal.
